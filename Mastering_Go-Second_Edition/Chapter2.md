# 第二章:理解go的本质

# 1.go编译器
	go tool compile test.go
	test.go->test.o
	go tool compile -pack test.go
	test.go->test.a

	file test.a
	结果:
	current ar archive

	file test.o
	current ar archive

	archive file 存档文件是包含一个或多个文件的二进制文件，主要是用于将多个文件分组为一个文件。 
	这些格式之一是ar，这是被Go使用。

	ar t test.a
	结果
	__.PKGDEF
	_go_.o

	go tool compile -S test.go更详细的信息

# 2.垃圾回收
	垃圾回收是释放未使用的内存空间的过程。 换句话说，垃圾收集器查看哪些对象不在范围内并且无法再被引用，并释放它们消耗的内存空间。 
	此过程在Go程序运行时（而不是在程序执行之前或之后）以并行方式发生。

	三色算法
	三色标级和清除算法

	三色标记和清除算法背后的主要原理是，它根据堆的颜色将堆的对象划分为三个不同的集合，这些颜色由算法分配。 
	现在是时候讨论每种颜色集的含义了。 保证黑色集合的对象没有指向白色集合的任何对象的指针。
	但是，白色集的对象可以具有指向黑色集的对象的指针，因为这对垃圾收集器的操作没有影响。 
	灰色集合的对象可能具有被指白色集合的某些对象指向的指针。 
	最后，白色集合的对象是垃圾收集的候选对象。

	请注意，没有对象可以直接从黑色集转到白色集，这允许算法进行操作并能够清除白色集上的对象。 
	此外，黑色组的任何对象都不能直接指向白色组的对象。
	因此，当垃圾回收开始时，所有对象都是白色的，垃圾回收器访问所有根对象，并将它们着色为灰色。 
	根是可以由应用程序直接访问的对象，其中包括全局变量和堆栈上的其他内容。 这些对象主要取决于特定程序的Go代码。
	此后，垃圾收集器选择一个灰色对象，使其变为黑色，然后开始查看该对象是否具有指向白色集合中其他对象的指针。 
	这意味着，当扫描灰色对象以寻找指向其他对象的指针时，该对象将变为黑色。 
	如果该扫描发现该特定对象具有一个或多个指向白色对象的指针，则会将该白色对象放入灰色集中。 
	只要灰色集中存在对象，此过程就会持续进行。 
	之后，白色集中的对象将无法访问，并且它们的存储空间可以被重用。 
	因此，在这一点上，白色集合的元素被认为是垃圾收集的。

	请注意，如果在垃圾回收周期的某个时刻灰色集合的某个对象变得不可访问，
	则不会在该垃圾回收周期中将其收集，而是在下一个垃圾回收中将其收集！ 尽管这不是最佳情况，但还不错。

    在此过程中，正在运行的应用程序称为mutator。 mutator运行一个名为write barrier的小函数，每次修改堆中的指针时都会执行该函数。 如果修改了堆中某个对象的指针，这意味着该对象现在可以访问，则write barrier将其着色为灰色并将其置于灰色集中。
    mutator负责变量，即黑色集合的元素都没有指向白色集合的元素的指针。 这是在write barrier的帮助下完成的。 无法完成该不变式将破坏垃圾回收过程，并且很有可能以一种非常糟糕且令人讨厌的方式使您的程序崩溃！

    time go run cf.go  
    程序运行计时
    结果go run cf.go 0.26s user 0.52s system 50% cpu 1.563 total

# defer关键词
    defer中文为延迟，延迟函数在返回周围函数后以后进先出（LIFO）的顺序执行。 
    简而言之，这意味着如果在同一个周围函数中先延迟函数f1（），然后再延迟函数f2（），然后再延迟函数f3（），
    则当周围函数即将返回时，将执行函数f3（） 首先，函数f2（）将被第二执行，函数f1（）将是最后一个要执行的函数。
    常用于关闭文件或者和recovery和panic结合使用


# Panic 和 recover
    func a() {
    	fmt.Println("Inside a()")
    	defer func() {
    		if c := recover(); c != nil {
    			fmt.Println("Recover inside a()!")
    		}
    	}()
    	fmt.Println("About to call b()")
    	b()
    	fmt.Println("b() exited!")
    	fmt.Println("Exiting a()")
    }

    func b() {
    	fmt.Println("Inside b()")
    	panic("Panic in b()!")
    	fmt.Println("Exiting b()")
    }
    
    func main() {
    	a()
    	fmt.Println("main() ended!")
    }
    
    panic会一层层往上调用，遇到recover之后不会执行该层后面的代码，panic一般适合recover成对出现的
    
    panic()和log.Panic()区别是panic()函数不会向您的UNIX计算机的日志记录服务发送任何内容。
    
    











